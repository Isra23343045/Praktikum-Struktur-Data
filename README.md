<a name="readme-top"></a>
<br />
<div align="center">
  <a href="https://github.com/github_username/repo_name">
    <img src="https://1.bp.blogspot.com/-KrHDhie5nic/Wi-TjOVtr4I/AAAAAAAAMYQ/XrxFafE7w8Anb-bcqZVKtvbBp1WgFZwdACLcBGAs/s1600/logo-universitas-negeri-padang-%2528unp%2529.png" alt="Logo" width="200" height="200">
  </a>

<h2 align="center">Praktikum Struktur Data</h2>

  <p align="center">
    Repositori ini berisi mengenai semua percobaan dan tugas dari perkuliahan praktikum struktur data pada Semester 2
    <br />
    <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data"><strong>Explore the docs Â»</strong></a>
    <br />
    <br />
    ğŸ““ Mata Kuliah : Praktikum Struktur Data
    <br />
    ğŸ‘¨â€ğŸ« Dosen: Randi Proska Sandra, M.Sc.
    <br />
    ğŸ« Kode kelas : Kode Kelas : INF1.62.2014.
  </p>
</div>



<!-- TABLE OF CONTENTS -->
<details>
  <summary>Table of Contents</summary>
  <ol>
    <li>
      <a href="#Jobsheet-1---Pengenalan-Struktur-Data">Jobsheet 1 - Pengenalan Struktur Data</a>
    </li>
    <li>
      <a href="#Jobsheet-2---Array-Pointer-Structure">Jobsheet 2 - Array, Pointer, Structure</a>
    </li>
    <li><a href="#Jobsheet-3---Single-Linked-List">Jobsheet 3 - Single Linked List</a></li>
    <li><a href="#Jobsheet-4---Doubly-Linked-List">Jobsheet 4 - Doubly Linked List</a></li>
    <li><a href="#Jobsheet-5---Double-and-Circular-Linked-List">Jobsheet 5 - Double and Circular Linked List</a></li>
    <li><a href="#Jobsheet-6---Stack">Jobsheet 6 - Stack</a></li>
    <li><a href="#Jobsheet-7---Queue">Jobsheet 7 - Queue</a></li>
    <li><a href="#Jobsheet-8---Bubble-and-Insertion-Sort">Jobsheet 8 - Bubble and Insertion Sort</a></li>
    <li><a href="#Jobsheet-9---Selection-and-Merge-Sort">Jobsheet 9 - Selection and Merge Sort</a></li>
    <li><a href="#Jobsheet-10---Shell-and-Quick-Sort">Jobsheet 10 - Shell and Quick Sort</a></li>
    <li><a href="#Jobsheet-11---Linear-and-Binary-Search">Jobsheet 11 - Linear and Binary Search</a></li>
    <li><a href="#Jobsheet-12---Tree">Jobsheet 12 - Tree</a></li>
    <li><a href="#Jobsheet-13---Graphs">Jobsheet 13 - Graphs</a></li>
  </ol>
</details>

<!-- ABOUT THE PROJECT -->
## Jobsheet 1 - Pengenalan Struktur Data

<img src="https://miro.medium.com/v2/resize:fit:2000/1*2rKGJ6h1regwmfMcty3SLw.png" width="80%" height="80%">

<p>
  Materi dari JOB SHEET 01 untuk mata kuliah Praktikum Struktur Data mencakup pengenalan dasar mengenai struktur data, dengan tujuan agar mahasiswa memahami konsep data, variabel, tipe data, dan struktur data serta mampu menerapkan dan memberikan contoh implementasi penyimpanan data menggunakan berbagai tipe data. Praktikum ini menggunakan perangkat lunak Notepad++ dan DevC IDE pada komputer pribadi. Teori singkatnya menjelaskan bahwa struktur data dalam pemrograman, khususnya dengan bahasa C, melibatkan variabel seperti Array, Struktur, dan Linked List yang memiliki karakteristik berbeda. Struktur data merupakan cara penyimpanan, penyusunan, dan pengaturan data untuk efisiensi.
</p>
<br/>
<p>
  Data sendiri adalah representasi fakta dunia nyata dalam berbagai bentuk. Terdapat empat istilah utama: tipe data, objek data, struktur data, dan berbagai kategori tipe data, termasuk tipe sederhana (tunggal dan majemuk) dan struktur data (sederhana dan majemuk). Pemahaman dan penggunaan struktur data yang tepat akan menghasilkan algoritma yang efisien dan program yang sederhana. Struktur data standar yang biasa digunakan mencakup List linier, Multilist, Stack, Queue, Tree, dan Graph. Praktikum juga mencakup percobaan pertama dengan program bahasa C dan tugas membuat artikel tentang topik-topik seperti Pointer, struct, dan array, serta berbagai jenis Linked List.
  <br/>
  <br/>
  <br/>
   <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%201/Tugas">Tugas Jobsheet 1</a>
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- GETTING STARTED -->
## Jobsheet 2 - Array Pointer Structure
<img src="https://www.ggorantala.dev/content/images/2023/04/Introduction-to-array-data-structure.png" width="80%" height="80%">

<p>
  Materi dari JOB SHEET 02 membahas tentang konsep Array, Pointer, Structure, dan Abstract Data Type (ADT) dalam pemrograman.Secara singkat, teori mengenai Array menjelaskan bahwa array adalah kumpulan nilai dengan tipe data yang sama, yang elemen-elemennya diakses menggunakan indeks. Deklarasi array bisa satu dimensi, dua dimensi, atau multi dimensi, dan contoh inisialisasinya termasuk deklarasi seperti `double balance[5] = {500.0, 2.0, 3.4, 7.0, 50.0};`.
  <br/>
  <br/>
  Pointer adalah variabel yang berisi alamat memori sebagai nilainya, berbeda dengan variabel biasa yang berisi nilai tertentu. Pointer digunakan untuk menyimpan alamat dari variabel lain, dan dideklarasikan dengan tanda asterisk (*) di depan nama variabel, misalnya `int *b, d;`. Untuk mendapatkan alamat memori dari variabel, digunakan tanda `&` di depan nama variabel, seperti `&b`.

  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%202">Tugas dan Percobaan Jobsheet 2</a>
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 3 - Single Linked List

<img src="https://mikirinkode.com/wp-content/uploads/2021/12/single-linked-list-thumbnail.png" width="80%" height="80%">
<p>
  Materi JOB SHEET 03 membahas topik Single Linked List.Teori singkat menjelaskan bahwa sebuah node dalam linked list berisi alamat dan data, yang keduanya dibungkus dalam sebuah objek berupa struct. Penggunaan alokasi memori dinamis memungkinkan kita untuk mengalokasikan memori saat program berjalan, berbeda dengan array yang bersifat statis. Fungsi `sizeof()` digunakan untuk mendapatkan ukuran tipe data atau variabel, sementara `malloc()` digunakan untuk mengalokasikan memori secara dinamis.
  <br/>
  <br/>
  Single Linked List adalah struktur data yang terdiri dari simpul-simpul beralamat yang saling bertaut, dimana setiap simpul menyimpan data dan alamat simpul berikutnya. Simpul pertama disebut HEAD dan simpul terakhir yang berisi alamat kosong disebut TAIL. Praktikum ini mencakup contoh program untuk membuat dan menampilkan linked list, serta operasi dasar seperti menambah elemen di awal, di tengah, dan di akhir linked list.
  <br/>
  <br/>
  Percobaan yang dilakukan melibatkan alokasi memori, pembuatan linked list tanpa typedef, dengan typedef, dan menampilkan linked list. Selain itu, juga dicontohkan bagaimana melakukan penyisipan elemen pada linked list. Tugas yang diberikan melibatkan pembuatan program untuk menampilkan bilangan Fibonacci dan bilangan prima menggunakan pointer dengan malloc, serta menggunakan realloc untuk mengalokasikan ukuran memori baru.
   <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%203">Tugas dan Percobaan Jobsheet 3</a>
</p>


<p align="right">(<a href="#readme-top">back to top</a>)</p>




## Jobsheet 4 - Doubly Linked List
<img src="https://sebhastian.com/doubly-linked-list-javascript/doubly-linked-list-example.png" width="80%" height="80%">

<p>
  Doubly Linked List (DLL) adalah jenis struktur data yang terdiri dari serangkaian node, di mana setiap node memiliki tiga komponen utama: data, pointer ke node berikutnya (next), dan pointer ke node sebelumnya (prev). Berbeda dengan Single Linked List (SLL) yang hanya memiliki satu arah pointer, DLL memungkinkan traversal dalam dua arah, baik maju (ke depan) maupun mundur (ke belakang). Hal ini menjadikan DLL lebih fleksibel dan efisien dalam operasi tertentu seperti penghapusan dan penyisipan node. Dalam penghapusan node, misalnya, DLL dapat langsung menggunakan pointer prev untuk mengakses node sebelumnya tanpa perlu traversal dari awal, yang sangat menghemat waktu terutama pada list yang panjang.
  <br/>
  <br/>
  Demikian pula, penyisipan node menjadi lebih mudah dan cepat karena adanya akses langsung ke node sebelum atau sesudah posisi penyisipan. Namun, kelemahan dari DLL adalah penggunaan memori yang lebih besar karena setiap node memerlukan ruang tambahan untuk menyimpan dua pointer. Meskipun demikian, manfaat yang diperoleh dari kemampuan traversal dua arah dan efisiensi operasi sering kali lebih besar daripada kelemahan ini, menjadikan DLL pilihan yang baik untuk aplikasi yang membutuhkan navigasi yang kompleks dan manipulasi data yang sering. Implementasi DLL sering kali digunakan dalam sistem perangkat lunak seperti browser yang membutuhkan fungsi navigasi maju-mundur, editor teks, dan berbagai aplikasi lain yang membutuhkan akses dan modifikasi data yang efisien.

  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%204">Tugas dan Percobaan Jobsheet 4</a>
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>




## Jobsheet 5 - Double and Circular Linked List
<img src="https://cdn.educba.com/academy/wp-content/uploads/2020/03/Circular-Linked-List-in-Data-Structure-m2-.jpg" width="80%" height="80%">
<p>
  Doubly Linked List (DLL) dan Circular Linked List (CLL) adalah dua jenis struktur data linked list yang digunakan untuk penyimpanan dan manipulasi data secara efisien. DLL terdiri dari serangkaian node di mana setiap node memiliki tiga komponen: data, pointer ke node berikutnya (next), dan pointer ke node sebelumnya (prev). Ini memungkinkan traversal dalam dua arah, baik maju maupun mundur, membuat operasi seperti penyisipan dan penghapusan node lebih efisien karena akses langsung ke node sebelumnya. Sementara itu, CLL adalah linked list di mana node terakhir menunjuk kembali ke node pertama, membentuk lingkaran tertutup. Ini memungkinkan traversal yang terus menerus tanpa perlu mencapai akhir list dan mulai dari awal lagi.
  <br/>
  <br/>
  Ada dua varian dari CLL: Singly Circular Linked List (SCLL) yang hanya memiliki pointer next dan Doubly Circular Linked List (DCLL) yang memiliki pointer next dan prev. Kedua struktur ini memiliki kelebihan dalam kasus penggunaan tertentu; DLL sangat efisien untuk navigasi dua arah dan operasi manipulasi data, sedangkan CLL ideal untuk aplikasi yang membutuhkan traversal berkelanjutan seperti buffer melingkar atau antrian berputar. Meskipun lebih kompleks dalam implementasi dibandingkan dengan linked list sederhana, keunggulan efisiensi dan fleksibilitas membuat DLL dan CLL menjadi pilihan populer dalam berbagai aplikasi pemrograman.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%205">Latihan,Tugas dan Percobaan Jobsheet 5</a>
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>



<!-- LICENSE -->
## Jobsheet 6 - Stack
<img src="https://inevitableeth.com/stack-banner.png" width="80%" height="80%">
<p>
  Stack adalah struktur data yang menawarkan pendekatan sederhana namun kuat dalam pengelolaan elemen data. Dalam konsep LIFO (Last In, First Out), elemen yang terakhir dimasukkan ke dalam stack akan menjadi yang pertama dikeluarkan. Ini mirip dengan cara kita menyusun tumpukan buku di atas meja, di mana buku terakhir yang diletakkan akan menjadi yang pertama diambil saat kita ingin mengambilnya kembali. Operasi utama dalam stack adalah push, yang digunakan untuk menambahkan elemen baru ke atas tumpukan, dan pop, yang menghapus dan mengembalikan elemen teratas. Selain itu, terdapat operasi peek yang memungkinkan kita melihat elemen teratas tanpa menghapusnya dari stack.
  <br/>
  <br/>
  Implementasi stack dapat dilakukan dengan menggunakan array atau linked list. Dalam array, stack diimplementasikan sebagai kumpulan elemen bertipe data yang dikelompokkan secara sekuensial dalam memori komputer. Di sisi lain, linked list memanfaatkan simpul-simpul yang saling terhubung, memungkinkan penambahan dan penghapusan elemen dengan lebih fleksibel. Stack sering digunakan dalam berbagai aplikasi, termasuk pengelolaan memori dalam bahasa pemrograman, penanganan ekspresi aritmatika dalam kompilasi, pencarian dalam algoritma Depth First Search (DFS), dan banyak lagi.
   <br/>
  <br/>
  Keunggulan utama stack adalah kesederhanaannya, yang memungkinkan implementasi dan penggunaannya dengan mudah. Kemampuannya dalam melacak urutan data dan memberikan akses cepat ke elemen teratas membuatnya menjadi pilihan yang populer dalam desain algoritma dan struktur data. Bahkan, dalam banyak kasus, stack dapat digunakan sebagai alat untuk menyelesaikan masalah kompleks dengan cara yang efisien dan elegan. Dengan demikian, stack merupakan salah satu konsep dasar yang penting bagi para pengembang perangkat lunak untuk dipahami dan dikuasai.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%206">Latihan,Tugas dan Percobaan Jobsheet 6</a>
  
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 7 - Queue
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221213113312/Queue-Data-Structures.png" width="80%" height="80%">
<p>
  Queue adalah struktur data yang mirip dengan antrian dalam kehidupan sehari-hari, di mana elemen-elemen ditambahkan ke ujung belakang (rear) dan dihapus dari ujung depan (front). Konsep FIFO (First In, First Out) digunakan dalam queue, yang berarti elemen yang pertama kali dimasukkan akan menjadi yang pertama kali dikeluarkan. Seperti saat kita mengantri di kasir supermarket, orang pertama yang mengantri akan dilayani terlebih dahulu sebelum orang-orang yang datang kemudian. Operasi utama dalam queue adalah enqueue, yang digunakan untuk menambahkan elemen baru ke dalam antrian, dan dequeue, yang menghapus dan mengembalikan elemen dari ujung depan antrian.
  <br/>
  <br/>
  Queue dapat diimplementasikan menggunakan array atau linked list. Implementasi menggunakan array memerlukan alokasi memori statis dan memiliki batasan ukuran yang tetap, sementara implementasi menggunakan linked list lebih fleksibel dalam hal alokasi memori. Ada juga variasi dari queue, seperti priority queue, di mana setiap elemen memiliki prioritas tertentu dan akan dikeluarkan sesuai dengan prioritasnya.
   <br/>
  <br/>
 Queue digunakan dalam berbagai aplikasi, termasuk sistem antrian layanan pelanggan, penjadwalan tugas dalam sistem operasi, dan algoritma Breadth First Search (BFS) dalam pencarian grafik. Kemampuannya untuk mengatur data secara terstruktur dan memberikan akses cepat ke elemen pertama serta kemampuan untuk menangani banyak operasi dengan efisien menjadikannya alat yang penting dalam pengembangan perangkat lunak. Dengan demikian, pemahaman tentang konsep dan penggunaan queue sangat penting bagi para pengembang perangkat lunak.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%207">Latihan,Tugas dan Percobaan Jobsheet 7</a>
  
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 8 - Bubble and Insertion Sort
<img src="https://cdn.productplan.com/wp-content/uploads/bubble-sort-1024x683-2.png" width="80%" height="80%">
<p>
  Bubble sort adalah salah satu algoritma pengurutan sederhana yang bekerja dengan cara berulang kali membandingkan pasangan elemen yang berdekatan dalam sebuah array, dan jika mereka tidak berada dalam urutan yang benar, menukar posisi mereka. Algoritma ini diulangi sampai tidak ada lagi pertukaran yang dibutuhkan, yang menunjukkan bahwa array sudah terurut.
  <br/>
  <br/>
  Proses bubble sort dimulai dari elemen pertama (indeks 0) dan berlanjut hingga elemen terakhir. Pada setiap iterasi, algoritma membandingkan pasangan elemen yang berdekatan. Jika elemen saat ini lebih besar dari elemen berikutnya, keduanya ditukar. Dengan demikian, elemen terbesar akan "menggelembung" ke bagian paling kanan dari array.
   <br/>
  <br/>
  <img src="https://www.boardinfinity.com/blog/content/images/2022/12/Your-paragraph-text--63-.jpg" width="80%" height="80%">
  <br/>
  Insertion sort adalah algoritma pengurutan sederhana yang bekerja dengan cara membagi array menjadi dua bagian: bagian yang sudah terurut dan bagian yang belum terurut. Pada setiap iterasi, insertion sort mengambil satu elemen dari bagian yang belum terurut dan memasukkannya ke dalam posisi yang tepat di bagian yang sudah terurut. Proses ini berlanjut sampai tidak ada lagi elemen yang tersisa dalam bagian yang belum terurut.
  <br/>
  <br/>
  Algoritma insertion sort secara umum lebih efisien daripada bubble sort dan selection sort, terutama untuk dataset yang hampir terurut atau memiliki ukuran kecil. Namun, insertion sort memiliki kompleksitas waktu rata-rata dan terburuk O(n^2), yang membuatnya kurang efisien untuk dataset yang sangat besar.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%208">Tugas dan Percobaan Jobsheet 8</a>
  
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 9 - Selection and Merge Sort
<img src="https://mikirinkode.com/wp-content/uploads/2021/11/selection-sort-thumbnail.png" width="80%" height="80%">
<p>
  Selection sort adalah algoritma pengurutan sederhana yang bekerja dengan cara secara berulang memilih elemen terkecil dari sisa array yang belum terurut dan menukarkannya dengan elemen di posisi awal dari bagian yang belum terurut. Proses ini dilakukan hingga seluruh array terurut.Meskipun selection sort relatif mudah dipahami dan diimplementasikan, ia memiliki kompleksitas waktu yang tidak efisien. Baik dalam kasus rata-rata maupun terburuk, kompleksitas waktu selection sort adalah O(n^2), di mana n merupakan jumlah elemen dalam array.
  <br/>
  <br/>
  Karena algoritma ini memerlukan banyak pertukaran data, terutama pada dataset besar, ia cenderung menjadi lambat. Namun, keuntungannya adalah selection sort memiliki sedikit overhead, terutama dalam hal memori, karena tidak memerlukan struktur data tambahan seperti tumpukan atau antrian.Karena keterbatasan dalam kinerjanya, selection sort lebih cocok untuk digunakan pada dataset yang relatif kecil atau saat kinerja algoritma tidak menjadi prioritas utama. Namun, ia sering digunakan sebagai contoh dasar dalam pembelajaran tentang algoritma pengurutan dan sebagai langkah awal dalam mengembangkan pemahaman tentang konsep-konsep dasar dalam pengurutan data.
   <br/>
  <br/>
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230706153706/Merge-Sort-Algorithm-(1).png" width="80%" height="80%">
  <br/>
  Merge sort adalah algoritma pengurutan yang menggunakan teknik pemisahan (divide) dan penggabungan (conquer) untuk mengurutkan sebuah array atau daftar data. Proses dimulai dengan membagi array menjadi dua bagian yang lebih kecil, kemudian masing-masing bagian diurutkan secara terpisah menggunakan rekursi. Setelah itu, bagian-bagian yang sudah diurutkan digabungkan kembali (merge) secara berurutan, dengan membandingkan dan menyusun elemen-elemen dari kedua bagian sesuai dengan urutan yang benar. Langkah ini diulangi secara rekursif hingga seluruh array terurut.
  <br/>
  <br/>
  Keuntungan utama dari merge sort adalah memiliki kompleksitas waktu yang stabil dan relatif cepat, yaitu O(n log n), di mana n merupakan jumlah elemen dalam array. Ini membuatnya efisien untuk digunakan pada dataset besar. Selain itu, merge sort bersifat stabil, artinya elemen-elemen yang memiliki nilai yang sama akan tetap dalam urutan relatif mereka setelah pengurutan.
Namun, merge sort memerlukan alokasi memori tambahan untuk menyimpan array sementara selama proses penggabungan, yang dapat mengurangi efisiensi pada dataset yang sangat besar. Selain itu, penggunaan rekursi dalam merge sort bisa menjadi mahal dari segi overhead pada beberapa bahasa pemrograman.
   <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%209">Tugas dan Percobaan Jobsheet 9</a>
  
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 10 - Shell and Quick Sort
<img src="https://www.mycplus.com/mycplus/wp-content/uploads/2021/02/Shell-Sort-Algorithm-1280x640.png" width="80%" height="80%">
<p>
  Shell sort adalah algoritma pengurutan yang merupakan modifikasi dari insertion sort, yang bertujuan untuk meningkatkan kinerja pengurutan dengan cara mengurangi jumlah perbandingan yang harus dilakukan. Prosesnya dimulai dengan membagi array menjadi beberapa subsequence yang lebih kecil, kemudian setiap subsequence diurutkan menggunakan insertion sort. Yang membedakan shell sort dari insertion sort adalah jarak (gap) antara elemen-elemen yang dibandingkan dalam setiap iterasi.
  <br/>
  <br/>
  Pada awalnya, gap yang digunakan besar, kemudian secara bertahap gap tersebut diperkecil hingga mencapai nilai 1. Dengan demikian, shell sort mengurutkan elemen-elemen dengan cara insertion sort, tetapi dengan memperhitungkan elemen-elemen yang berjarak jauh satu sama lain terlebih dahulu. Hal ini memungkinkan elemen-elemen yang lebih kecil atau lebih besar untuk "melompat" ke posisi mereka dengan cepat, mengurangi jumlah perbandingan yang harus dilakukan dalam proses pengurutan.
   <br/>
  <br/>
  <img src="https://i.ytimg.com/vi/OGVGDgc9BAo/maxresdefault.jpg" width="80%" height="80%">
  <br/>
  Quick sort adalah algoritma pengurutan yang efisien dan sering digunakan dalam pemrosesan data. Metode ini mengadopsi pendekatan divide and conquer, di mana array dibagi menjadi dua subarray berdasarkan elemen pivot. Elemen pivot dipilih dari array yang akan diurutkan dan digunakan sebagai pemisah antara elemen yang lebih kecil dan lebih besar daripada pivot. Setelah pemisahan, algoritma secara rekursif mengurutkan kedua subarray secara independen menggunakan teknik yang sama hingga seluruh array terurut. Karena pendekatan rekursifnya, quick sort memiliki kompleksitas waktu rata-rata O(n log n), menjadikannya salah satu algoritma pengurutan yang paling cepat dalam praktiknya.
   <br/>
  <br/>
  Keunggulan utama dari quick sort adalah kinerja yang cepat dan efisien, terutama pada dataset yang besar. Selain itu, algoritma ini tidak membutuhkan ruang tambahan untuk penyimpanan data sementara, yang membuatnya lebih efisien dalam penggunaan memori. Namun, quick sort memiliki beberapa kelemahan, terutama ketika elemen pivot dipilih dengan buruk, dapat menyebabkan kinerja algoritma menjadi buruk, meskipun ini dapat diperbaiki dengan memilih pivot secara acak atau dengan menggunakan heuristik lainnya. Selain itu, quick sort bersifat tidak stabil, artinya ia tidak mempertahankan urutan relatif elemen-elemen yang sama nilainya dalam array yang terurut. Meskipun demikian, quick sort tetap menjadi salah satu algoritma pengurutan yang paling populer dan banyak digunakan dalam berbagai konteks pemrograman.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%2010">Tugas dan Percobaan Jobsheet 10</a>
  
</p>

<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 11 - Linear and Binary Search
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Linear-Search.png" width="80%" height="80%">
<p>
  Linear search, juga dikenal sebagai sequential search, adalah metode sederhana untuk mencari nilai tertentu dalam sebuah array atau daftar. Algoritma ini bekerja dengan memeriksa setiap elemen dalam urutan, satu per satu, mulai dari awal hingga akhir array, untuk mencocokkan nilai yang dicari. Jika nilai yang dicari ditemukan, linear search akan mengembalikan indeks di mana nilai tersebut pertama kali ditemukan dalam array. Namun, jika nilai tidak ditemukan, algoritma akan menyelesaikan pencarian setelah memeriksa semua elemen dan mengembalikan nilai yang menunjukkan bahwa nilai tersebut tidak ada dalam array.
  <br/>
  <br/>
  Keuntungan dari linear search adalah kesederhanaannya dan kemampuannya untuk bekerja pada array yang tidak diurutkan. Namun, karena algoritma ini memeriksa setiap elemen satu per satu, kompleksitas waktu pencariannya adalah O(n), di mana n adalah jumlah elemen dalam array. Oleh karena itu, linear search tidak efisien untuk dataset yang besar atau saat efisiensi waktu sangat penting. Meskipun demikian, linear search tetap menjadi pilihan yang cocok untuk dataset yang kecil atau ketika array tidak diurutkan.
   <br/>
  <br/>
  <img src="https://i.ytimg.com/vi/tfq_T2cM_fc/maxresdefault.jpg" width="80%" height="80%">
  <br/>
  Binary search adalah algoritma pencarian yang digunakan untuk menemukan nilai tertentu dalam sebuah array yang diurutkan secara terurut naik. Algoritma ini membagi array menjadi dua bagian, memeriksa elemen tengah, dan membandingkannya dengan nilai yang dicari. Jika nilai di tengah array sama dengan nilai yang dicari, pencarian selesai. Namun, jika nilai di tengah lebih besar dari nilai yang dicari, algoritma akan mencari di setengah kiri array; jika nilai di tengah lebih kecil, algoritma akan mencari di setengah kanan array. Proses ini berulang secara rekursif pada setengah array yang relevan hingga nilai yang dicari ditemukan atau tidak ditemukan.
  <br/>
  <br/>
  Keuntungan utama binary search adalah kompleksitas waktu yang lebih baik daripada linear search. Karena setiap iterasi membagi ukuran array menjadi setengah, kompleksitas waktu binary search adalah O(log n), di mana n adalah jumlah elemen dalam array. Oleh karena itu, algoritma ini sangat efisien untuk dataset yang besar. Namun, penting untuk dicatat bahwa binary search hanya dapat digunakan pada array yang diurutkan, dan implementasinya tidak efisien jika array sering berubah atau diubah.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%2011">Tugas dan Percobaan Jobsheet 11</a>
  
</p>
<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 12 - Tree
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20221124153129/Treedatastructure.png" width="80%" height="80%">
<p>
  Tree adalah struktur data yang terdiri dari simpul-simpul yang terhubung satu sama lain melalui tepi atau cabang. Struktur ini mirip dengan pohon kebalikan, dengan akar di bagian atas dan cabang-cabang menjalar ke bawah. Setiap simpul dalam pohon memiliki satu simpul induk (kecuali simpul akar) dan nol atau lebih simpul anak. Simpul yang tidak memiliki anak disebut simpul daun, sementara simpul yang memiliki setidaknya satu anak disebut simpul dalam.
  <br/>
  <br/>
  Sebuah pohon terdiri dari serangkaian simpul, yang masing-masing dapat memiliki nilai data atau informasi tambahan. Tree umumnya digunakan untuk menyimpan data hierarkis, seperti struktur file dalam sistem operasi atau hierarki organisasi dalam perusahaan. Jenis pohon yang umum digunakan termasuk binary tree, binary search tree, AVL tree, dan Red-Black tree, masing-masing dengan aturan dan sifat khususnya. Tree juga memiliki berbagai operasi yang bisa dilakukan, seperti pencarian, penambahan, penghapusan, dan traversal, yang memungkinkan akses dan manipulasi data secara efisien.
   <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%2012">Percobaan Jobsheet 12</a>
  
</p>
<p align="right">(<a href="#readme-top">back to top</a>)</p>

## Jobsheet 13 - Graphs
<img src="https://www.boardinfinity.com/blog/content/images/2023/01/Graphs-in-DSA.png" width="80%" height="80%">
<p>
  Graf adalah struktur data yang terdiri dari kumpulan simpul atau node yang terhubung oleh sisi atau edge. Setiap sisi dapat memiliki bobot atau nilai tertentu yang menggambarkan hubungan antara dua simpul tersebut. Graf digunakan untuk merepresentasikan berbagai jenis hubungan antara objek dalam dunia nyata, seperti jaringan sosial, jaringan transportasi, dan hubungan antarobjek dalam sistem informasi.
Graf memiliki dua jenis utama: graf terarah dan graf tak terarah. Pada graf terarah, setiap sisi memiliki arah yang menunjukkan hubungan satu arah antara dua simpul, sedangkan pada graf tak terarah, sisi tidak memiliki arah, yang berarti hubungan antara dua simpul adalah saling mengalir.
  <br/>
  <br/>
  Ada beberapa representasi yang digunakan untuk menyimpan graf dalam komputer, termasuk representasi matriks dan representasi daftar. Representasi matriks menggunakan matriks dua dimensi untuk menyimpan informasi tentang hubungan antara simpul-simpul, sedangkan representasi daftar menggunakan daftar terkait untuk menyimpan informasi tentang tetangga-tetangga setiap simpul.
Graf digunakan dalam berbagai algoritma dan aplikasi, termasuk algoritma pencarian jalur terpendek seperti Dijkstra dan Bellman-Ford, algoritma pencarian lintasan terpendek seperti algoritma A*, serta dalam algoritma pencarian dalam kedalaman (depth-first search) dan algoritma pencarian dalam lebar (breadth-first search) untuk traversal graf. Selain itu, graf juga digunakan dalam analisis jaringan, optimisasi rute, pemetaan jaringan sosial, dan banyak lagi. Kemampuan untuk merepresentasikan hubungan kompleks antara objek membuat graf menjadi struktur data yang sangat penting dalam ilmu komputer dan aplikasinya dalam berbagai bidang.
  <br/>
  <br/>
  <a href="https://github.com/Isra23343045/Praktikum-Struktur-Data/tree/main/JOBSHEET%2013">Percobaan Jobsheet 13</a>
  
</p>
<p align="right">(<a href="#readme-top">back to top</a>)</p>
<!-- CONTACT -->

## Contact

Muhammad Isra alfattah - [facebook@isra_alfattah](https://www.facebook.com/profile.php?id=100013991084817) - email@alfattah.isra@gmail.com

Project Link: [https://github.com/github_username/repo_name](https://github.com/github_username/repo_name)

<p align="right">(<a href="#readme-top">back to top</a>)</p>







<!-- MARKDOWN LINKS & IMAGES -->
<!-- https://www.markdownguide.org/basic-syntax/#reference-style-links -->
[contributors-shield]: https://img.shields.io/github/contributors/github_username/repo_name.svg?style=for-the-badge
[contributors-url]: https://github.com/github_username/repo_name/graphs/contributors
[forks-shield]: https://img.shields.io/github/forks/github_username/repo_name.svg?style=for-the-badge
[forks-url]: https://github.com/github_username/repo_name/network/members
[stars-shield]: https://img.shields.io/github/stars/github_username/repo_name.svg?style=for-the-badge
[stars-url]: https://github.com/github_username/repo_name/stargazers
[issues-shield]: https://img.shields.io/github/issues/github_username/repo_name.svg?style=for-the-badge
[issues-url]: https://github.com/github_username/repo_name/issues
[license-shield]: https://img.shields.io/github/license/github_username/repo_name.svg?style=for-the-badge
[license-url]: https://github.com/github_username/repo_name/blob/master/LICENSE.txt
[linkedin-shield]: https://img.shields.io/badge/-LinkedIn-black.svg?style=for-the-badge&logo=linkedin&colorB=555
[linkedin-url]: https://linkedin.com/in/linkedin_username
[product-screenshot]: images/screenshot.png
[Next.js]: https://img.shields.io/badge/next.js-000000?style=for-the-badge&logo=nextdotjs&logoColor=white
[Next-url]: https://nextjs.org/
[React.js]: https://img.shields.io/badge/React-20232A?style=for-the-badge&logo=react&logoColor=61DAFB
[React-url]: https://reactjs.org/
[Vue.js]: https://img.shields.io/badge/Vue.js-35495E?style=for-the-badge&logo=vuedotjs&logoColor=4FC08D
[Vue-url]: https://vuejs.org/
[Angular.io]: https://img.shields.io/badge/Angular-DD0031?style=for-the-badge&logo=angular&logoColor=white
[Angular-url]: https://angular.io/
[Svelte.dev]: https://img.shields.io/badge/Svelte-4A4A55?style=for-the-badge&logo=svelte&logoColor=FF3E00
[Svelte-url]: https://svelte.dev/
[Laravel.com]: https://img.shields.io/badge/Laravel-FF2D20?style=for-the-badge&logo=laravel&logoColor=white
[Laravel-url]: https://laravel.com
[Bootstrap.com]: https://img.shields.io/badge/Bootstrap-563D7C?style=for-the-badge&logo=bootstrap&logoColor=white
[Bootstrap-url]: https://getbootstrap.com
[JQuery.com]: https://img.shields.io/badge/jQuery-0769AD?style=for-the-badge&logo=jquery&logoColor=white
[JQuery-url]: https://jquery.com 
